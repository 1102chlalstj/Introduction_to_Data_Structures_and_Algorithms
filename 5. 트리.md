## 트리
- 아래의 조건을 만족하는 **하나 이상의 노드들로 구성된 유한 집합 T** (재귀적 정의)
  - 노드들 중에는 루트(Root)라 불리는 하나의 특별한 노드가 존재
  - 루트를 제외한 나머지 노드들은 원소가 중복되지 않는 N(≥ 0) 개의 부분 집합 $$T_1, T_2, ..., T_N$$으로 나누어지며 $$T_i$$(1 ≤ i ≤ N)는 하나의 트리임, 이 때 각 $$T_i$$를 트리 T의 **서브 트리**라고 부름
- 용어: 노드, 자식 노드, 부모 노드, 차수, 트리의 차수, 남매 혹은 형제 혹은 자매 노드, 루트 노드, 단말 노드, 내부 혹은 비단말 노드, 경로, 조상 노드, 서브 트리, 후손 노드, 레벨 혹은 깊이, 트리의 높이, 키

### 왼쪽 자식-오른쪽 남매 표현
- 트리의 저장: 물리적 구현의 단순성을 위해서 모든 노드가 트리의 차수 K만큼의 참조를 저장하는 것이 바람직
- 단점:
  - 차수가 K인 트리 T에 존재하는 노드의 수가 N일 때, (None 값을 저장하고 있는 링크 필드의 수) = (모든 링크 필드의 수) - (간선 수) = NꞏK - (N - 1)
  - 메모리 낭비
  - 탐색 과정에서 참조가 None인 링크 필드도 확인 -> 시간적으로 비효율적
- **왼쪽 자식-오른쪽 남매 표현 방법**은 **K의 값을 2로 제한**

### 이진 트리
- empty이거나, empty가 아니면 루트 노드와 두 개의 이진 트리인 왼쪽 서브 트리와 오른쪽 서브 트리로 구성된 트리 (재귀적 정의)
- 모든 노드의 차수가 2를 넘지 않음, 임의의 노드는 **최대 두 개의 자식 노드** 가짐
- **자식 노드의 순서를 구별**
- **이진 트리는 empty가 존재하지만, 차수가 2인 트리는 empty가 존재하지 않음**
- 이진 트리는 서브 트리들의 순서를 구별하지만, 차수가 2인 트리는 서브 트리들의 순서를 구별하지 않음
- 특별한 형태의 이진 트리
  - 완벽 이진 트리: 각 내부 노드가 두 개의 자식 노드를 가지는 이진 트리
  - 완전 이진 트리: 마지막 레벨을 제외한 각 레벨이 노드들로 꽉 차있고, 마지막 레벨에는 노드들이 왼쪽부터 빠짐없이 채워진 트리
  - 완벽 이진 트리라면 완전 이진 트리, 역은 성립 X
  - 이진 트리의 레벨 i에 존재할 수 있는 최대 노드의 수는 $$2^i$$
  - **높이가 h인 완벽 이진 트리에 존재하는 모든 노드의 수 $$N = 2^{h+1} - 1$$**
  - **완벽 이진 트리에 존재하는 노드의 수가 N이라면 해당 트리의 높이 $$h = log_2(N+1) - 1$$**
  - **높이가 h인 완전 이진 트리에 존재할 수 있는 노드의 수 N은 $$2^h \leq N \leq 2^{h+1} - 1$$**
  - **완전 이진 트리에 존재하는 노드의 수가 N이라면 해당 트리의 높이 $$h = ⌈ log_2(N+1) ⌉ - 1$$**
  - **이진 트리에 존재하는 노드의 수가 N일 때 해당 트리의 최대 높이 $$h = N - 1$$ (선형 구조)**
 
### 이진 트리의 구현
- Python 리스트를 이용한 표현
  - empty인 Python 리스트 T를 생성 후, 레벨 0부터 마지막 레벨 순서로 내려가며, 각 레벨에서는 좌에서 우로 트리의 노드들을 append(item)을 이용하여 T[0]부터 차례로 저장
  - **T[i]의 왼쪽 자식 노드: T[2ꞏi + 1]**
  - **T[i]의 오른쪽 자식 노드: T[2ꞏ(i + 1)]**
  - **T[i]의 부모 노드: T[(i - 1) // 2]**
  - 편향 이진 트리를 표현할 경우 메모리 낭비가 심화
  - 완전 이진 트리는 메모리 낭비 없음
- 노드들의 참조를 이용하여 연결시키는 구현
  - 단위: 노드(**키, left 링크 필드, right 링크 필드**)
  - cf) get_left(), get_right() 연산 시 노드 객체의 클래스 이름과 주소가 출력. 자식 노드의 값을 출력하기 위해서는 뒤에 get_key() 사용!
  - 연산:
    - BinaryTree(): 빈 이진 트리 생성
    - preorder(node): 이진 트리를 전위 순회
    - inorder(node): 이진 트리를 중위 순회
    - postorder(node): 이진 트리를 후위 순회
    - levelorder(node): 이진 트리를 레벨 순회

|이진 트리 연산|BinaryTree()|preorder(node)|inorder(node)|postorder(node)|levelorder(node)|
|-|-|-|-|-|-|
|시간 복잡도|O(1)|O(N)|O(N)|O(N)|O(N)|
|비고||순회|순회|순회|순회|

### 우선순위 큐
- **임의의 기준을 중심**으로 가장 높은 우선순위를 가지는 항목의 삭제 및 반환을 보장하는 큐
- 스택: **시간 중심**, 삽입된 시간이 최근 시간일수록 더 높은 우선순위를 부여
- 큐: **시간 중심**, 삽입된 시간이 이른 시간일수록 더 높은 우선순위를 부여
- 스택과 큐는 **우선순위 큐의 특수한 형태**
- 본 강의에서는 작은 값 우선
- 연산:
  - PriorityQueue(): 새로운 우선순위 큐 생성
  - enqueue(item): 기존 Rear 위치에 item 삽입
  - dequeue(): 우선순위가 가장 높은 item **삭제 및 반환**

|우선순위 큐 연산의 시간 복잡도|PriorityQueue()|enqueue(item)|dequeue()|
|-|-|-|-|
|Python 리스트에 의한 구현|O(1)|O(1)|O(N)|
|정렬된 동적 배열(내림차순)에 의한 구현|O(1)|O(N)|O(1)|
|정렬된 단순 연결 리스트(오름차순)에 의한 구현|O(1)|O(N)|O(1)|
|cf) 힙||O(logN)|O(logN)|

|참고|1개 삽입|n개 삽입|임의의 배열을 해당 구조로 만들기|
|-|-|-|-|
|정렬된 배열|O(N)|O($$N^2$$)|평균 O(NlogN)보다 좋을 수 없음|
|힙|O(logN)|O(logN)|평균 O(N)|

### 힙
- 완전 이진 트리
- **힙 속성: 부모 노드 키 값의 우선순위가 자식 노드 키 값의 우선순위보다 높음**
- 종류: MAX 힙(루트 노드의 키가 가장 큼), **MIN 힙**(루트 노드의 키가 가장 작음)
- 본 강의에서는 MIN 힙에 초점

### 힙의 구현
- Python 리스트(동적 배열)로 구현
  - **items[i]의 왼쪽 자식 노드: T[2ꞏi + 1]**
  - **items[i]의 오른쪽 자식 노드: T[2ꞏ(i + 1)]**
  - **items[i]의 부모 노드: T[(i - 1) // 2]**
  - **노드 수가 N일 때, 첫 번째 단말 노드: T[⌊N / 2⌋] = T[N // 2]**
  - **단말 노드: T[N // 2]부터 T[N - 1]까지**
- 연산:
  - BinaryHeap(array = []): 빈 힙 생성 혹은 item들의 array를 담고 있는 Python 리스트 생성
  - size(): 힙의 사이즈 반환
  - insert(key): 힙에 새 노드 삽입, enheap(key)
    - upheap(i): 아래에서 위로 올라가며 힙 속성을 회복, W(N) = $$⌈log_2(N+1)⌉ - 1$$ (최악의 경우 힙의 높이 만큼 swap)
  - extract_min(): 힙에서 루트 노드 삭제 및 (키 값) 반환, deheap()
    - downheap(i): 위에서 아래로 내려가며 힙 속성을 회복, W(N) = $$⌈log_2(N+1)⌉ - 1$$ (최악의 경우 힙의 높이 만큼 swap)
  - build_heap(array): 입력 받은 item들의 array를 힙으로 반환
    - 하향식 알고리즘의 시간 복잡도: O(NlogN)
    - 상향식 알고리즘의 시간 복잡도: O(N)
  - print_heap(): 힙의 노드 및 사이즈 출력
 
|힙 연산|BinaryHeap(array = [])|size()|swap(i, j)|upheap(i)|insert(key)|downheap(i)|extract_min()|build_heap(array)|print_heap()|
|-|-|-|-|-|-|-|-|-|-|
|시간 복잡도|- Python: O(1) <br> - 다른 언어: O(N)|O(1)|O(1)|O(logN)|O(logN)|O(logN)|O(logN)|O(N)|O(N)|

### 탐색
- 컴퓨터가 가장 많이 수행하는 연산
- 선형 탐색: 처음 항목부터 마지막 항목까지 하나씩 검사하면서 특정 값(검색 키)과 동일한 키 값을 가지는 항목을 찾는 방법
  - 시간 복잡도: O(N)
- 이진 탐색: **정렬된 배열**을 중간에 위치한 항목을 기준으로 두 부분으로 나누어가며 검색 키와 동일한 키 값을 가지는 항목을 찾는 방법
  - 시간 복잡도: O(logN)

### 이진 탐색 트리
- 다음의 조건을 만족하는 이진 트리 (재귀적 정의)
  - 모든 노드들의 키는 서로 다른 **유일한 값**을 가짐
  - 특정 노드 N의 키 값이 N의 왼쪽 서브 트리에 존재하는 모든 노드들의 키 값보다 크고, N의 오른쪽 서브 트리에 있는 모든 노드들의 키 값보다 작음
    - 중위 순회하면 노드들의 키 값이 오름차순으로 출력
  - N의 왼쪽 서브 트리와 오른쪽 서브 트리도 이진 탐색 트리임

### 이진 탐색 트리의 구현
- 노드들의 참조를 이용하여 연결시키는 구현
  - 단위: 노드(키, left 링크 필드, right 링크 필드)
  - Protected Method 사용: 정보 은닉, 사용자가 마음대로 트리의 구조 변경 X
- 연산:
  - BST(): 빈 이진 탐색 트리 생성
  - search(k): 검색 키 값인 k와 같은 키 값을 가지는 노드가 존재하면 True 반환
  - insert(key): 키 값 key를 가지는 노드 삽입
  - find_min(): 키 값이 최소인 노드 탐색
  - delete_min(): 키 값이 최소인 노드 탐색
  - delete(key): 키 값 key를 가지는 노드 삭제

|힙 연산|BST()|search(k)|insert(key)|find_min()|delete_min()|delete(key)|
|-|-|-|-|-|-|-|
|시간 복잡도|O(1)|O(h), h는 트리의 높이(일반적으로 O(logN), 편향된 이진 탐색 트리의 경우 O(N))|O(h), h는 트리의 높이(일반적으로 O(logN), 편향된 이진 탐색 트리의 경우 O(N))|O(h), h는 트리의 높이(일반적으로 O(logN), 편향된 이진 탐색 트리의 경우 O(N))|O(h), h는 트리의 높이(일반적으로 O(logN), 편향된 이진 탐색 트리의 경우 O(N))|O(h), h는 트리의 높이(일반적으로 O(logN), 편향된 이진 탐색 트리의 경우 O(N))|
